---
title: 对象创建
author: 云影sky
---

## 创建对象的几种基本方式

- `{}` 对象字面量
- `Object()` 或者 `new Object()`
- `new Constructor()`
- `Object.create()`
- `Object.assign()`

## 工厂模式

```js
function createPerson(name, age, job) {
  const o = new Object();
  o.name = name;
  o.age = age;
  o.job = job;
  o.sayName = function() {
    console.log(this.name);
  };
  return o;
}
const person1 = createPerson("Nicholas", 29, "Software Engineer");
const person2 = createPerson("Greg", 27, "Doctor");
```

每一次调用上面的 `createPerson` 工厂函数都可以创建一个对象，这个对象有 `name` `age` `job` 三个属性和一个 `sayName` 方法，依据传入的参数的不同，返回对象的值也会不同。

缺点：没有解决这个对象是一个什么类型的对象（没有更精确的对象标识，没有精确的构造函数）。

## 构造函数模式

将工厂改造成构造函数之后，如下

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = function() {
    console.log(this.name);
  };
}
const person1 = new Person("Nicholas", 29, "Software Engineer");
const person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

构造函数和工厂的区别：

1. 没有显式创建对象；
2. 直接把属性和方法赋值给 `this`
3. 没有 `return`

使用构造函数创建对象将会有以下几个步骤：

1. 在内存中创建一个新对象
2. 新对象内部的 `[[Prototype]]` 指针指向构造函数的 `prototype` 属性指向的对象；
3. 将构造函数的上下文 `this` 指向新创建的对象；
4. 执行构造函数内部的代码（给新对象添加属性）；
5. 如果构造函数 `return` 非 `null` 的对象，那返回的就是这个对象，否则返回新创建的这个对象。没有 `return` 时，隐式返回新创建的对象，`return null` 会返回新创建的对象；

缺点：每次实例化一个新对象，都会在内部创建一个 `sayName` 对应的匿名函数，而这个函数对所有实例来讲是没有必要每次都创建的，他们只需要指向同一个函数即可。

所以上面的代码经过改造之后，变成下面这样：

```js
function Person(name, age, job) {
  this.name = name;
  this.age = age;
  this.job = job;
  this.sayName = sayName;
}
function sayName() {
  console.log(this.name);
}
const person1 = new Person("Nicholas", 29, "Software Engineer");
const person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```

上述的做法虽然解决了重复创建匿名函数的问题，但是又引入了新的问题。

外面的 `sayName` 函数仅仅在构造函数中用到，如果对象需要很多个这样的函数，那么就需要在外部定义很多个这种函数，这无疑会导致代码很难组织。

## 原型模式

函数创建之后都会有一个 `prototype` 属性，每个使用该构造函数创建的对象都有一个 `[[prototype]]` 内部属性指向它。

使用原型的好处在于它所有的属性和方法会在实例间共享，并且这个共享的属性和方法是直接在原型上设置的。

```js
function Person() {}

Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
  console.log(this.name);
};
const person1 = new Person();
person1.sayName(); // "Nicholas"
const person2 = new Person();
person2.sayName(); // "Nicholas"
console.log(person1.sayName == person2.sayName); // true
```

关于原型的工作原理，可以查看下面三篇文章，看完之后相信你对原型的认识比大多数人都要深刻！

1. [前端面试必备 | 5000 字长文解释千万不能错过的原型操作方法及其模拟实现（原型篇：下）](https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&mid=2247483946&idx=1&sn=acbf08e208b23ddd813c2f3266f375c0&chksm=fd3c3e82ca4bb79458205dde161449b483317ae45eb214b0225af467bc448f398c4f09cd9999&token=479601613&lang=zh_CN#rd)
1. [前端面试必备 | 古怪的原型（鸡生蛋还是蛋生鸡）（原型篇：中）](https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&mid=2247483942&idx=1&sn=20d88f820800bcb6b6374096cea25a93&chksm=fd3c3e8eca4bb7984588fbfe10609e12df6087bfd32939a1a99ce95682c6233acc42de362139&token=92313189&lang=zh_CN#rd)
1. [前端面试必备 | 使用原型和构造函数创建对象（原型篇：上）](https://mp.weixin.qq.com/s?__biz=MzU3MzcxMzg2Mw==&mid=2247483938&idx=1&sn=60586911f43a69a905801e5407c2b8e7&chksm=fd3c3e8aca4bb79cd5c7bb64e6c6e5df0c7da3129d7481c8d51e1a9a0590fe4359bbaef575d2&token=212038910&lang=zh_CN#rd)

### 理解原型的层级

对象中属性的查找机制：

当从对象中访问一个属性的时候，JS 引擎将会按属性名进行查找。JS 引擎会先查找对象自身。如果找到了这个属性，就会停止查找并返回属性对应的值，如果在对象自身没有找到，则会通过原型链到原型对象中继续查找这个属性，如果找到了这个属性，就会停止查找并返回属性对应的值，否则会继续到上层原型链中查找，直到碰到 `null` 。

当一个属性添加到实例中时，这个属性会覆盖原型上的同名属性，这个覆盖指的是查找的时候不会到原型中查找同名属性。即使属性的值被赋值为 `null` 或 `undefined`，它依然会阻止到原型链上访问。所以如果想要访问，就需要删除这个属性，使用 `delete obj.xx` 。

可以使用 `hasOwnProperty` 判断实例是否拥有某个属性，返回 `true` 则表示实例本身拥有该属性，否则表示它没有这个属性。当一个属性存在于原型链上时，可以访问到这个属性，但是使用 `hasOwnProperty` 将返回 `false`。

### `in` 操作符

`in` 操作符用在两个地方，一个是用在 `for ... in` 循环中，另一个是单独使用。单独使用时，返回 `true` 表示属性可以在对象或者其原型链上找到。

```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
  console.log(this.name);
};
const person1 = new Person();
const person2 = new Person();
console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true
person1.name = "Greg";
console.log(person1.name); // "Greg" - from instance
console.log(person1.hasOwnProperty("name")); // true
console.log("name" in person1); // true
console.log(person2.name); // "Nicholas" - from prototype
console.log(person2.hasOwnProperty("name")); // false
console.log("name" in person2); // true
delete person1.name;
console.log(person1.name); // "Nicholas" - from the prototype
console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true
```

可以通过组合使用 `hasOwnProperty` 和 `in` 来实现判断一个属性是否存在于原型链上：

```js
function hasPrototypeProperty(object, name) {
  return !object.hasOwnProperty(name) && name in object;
}
const obj = Object.create({ name: "lxfriday" });
console.log(obj);
console.log(hasPrototypeProperty(obj, "name"));
```

**关于对象属性的枚举顺序**

`for ... in` `Object.keys()` `Object.getOwnPropertyNames/Symbols()` 和 `Object.assign()` 在处理属性枚举顺序的时候会有很大差别。

**`for ... in` `Object.keys()` 没有确定的枚举顺序，它们的顺序取决于浏览器实现。**

而 `Object.getOwnPropertyNames()` `Object.getOwnPropertySymbols()` 和 `Object.assign()` 是有确定的枚举顺序的。

1. 数字键会按照升序先枚举出来；
2. 字符串和 symbol 键按照插入的顺序枚举出来；
3. 对象字面量中定义的键会按照代码中的逗号分割顺序枚举出来；

```js
const k2 = Symbol("k2");
const k1 = Symbol("k1");
const o = { 1: 1, [k2]: "sym2", second: "second", 0: 0, first: "first" };
o[k1] = "sym1";
o[3] = 3;
o.third = "third";
o[2] = 2;
// [ '0', '1', '2', '3', 'second', 'first', 'third' ]
console.log(Object.getOwnPropertyNames(o));
// [ Symbol(k2), Symbol(k1) ]
console.log(Object.getOwnPropertySymbols(o));
```
